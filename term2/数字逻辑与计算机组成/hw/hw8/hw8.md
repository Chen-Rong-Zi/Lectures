## 3.
![3](/home/rongzi/Pictures/screenshot/24-06-11_21:23:55.png)
1.  该计算机的编址单位是多少？
2个字节
2. 画出实现Bgt指令的数据通路
![3](/home/rongzi/Pictures/screenshot/24-06-11_23:02:51.png)


## 4
![4](/home/rongzi/Pictures/screenshot/24-06-11_21:33:58.png)
1. 若RegWr = 0, 
所有需要将计算结果写入寄存器的指令都失灵

2. 若ALUASrc = 0
则由于pc不能正确载入ALU中，不能完成下一指令地址的计算，所以jal和auipc不能正确执行

3. 若ALUBSrc = 0
则由于来自寄存器独处的操作数未扩展或为4，ALU的B端输入错误，导致不能正确执行。

4. 若jump = 0
则jal（无条件跳转）失灵

6. 若MemWr = 0
则数据无法存入内存，所有s型数据不能正确执行。

## 5
![5](/home/rongzi/Pictures/screenshot/24-06-11_21:42:47.png)

1. 若RegWr = 1,
所有不需要将计算结果写入寄存器的指令都失灵

2. 若ALUASrc = 1
则由于pc总被载入ALU中，所以jal和auipc以外的指令不能正确执行

3. 若Branch = 1
则所有指令均会跳转，只有B指令正确执行。

4. 若MemtoReg = 1
则除了加载内存数据的指令可以正确执行外，其余指令都会获得内存而不是ALU的数据。

## 6
![6](/home/rongzi/Pictures/screenshot/24-06-11_23:09:42.png)
1. 软件方法实现swap指令
```
swap:
    xor t0, a, b
    xor a, a, b
    xor b, t0, a
```
2.
设该指令占总指令的x% ,其他指令占 (1-x)% 则用硬件实现该指令时,
程序执行时间为原来的 1.1*(x 1-x) =1.1 倍
软件实现,程序执行时间为原来的   3x + 1 - x = ( 2x + 1)倍
由此可知, x > 5% 时硬件实现才有意义

## 11
![11](/home/rongzi/Pictures/screenshot/24-06-11_23:02:51.png)
1. 若ALU操作时间加快20%，不会影响指令速度，因为指令执行速度取决于存储器的操作时间（因为存储器操作时间最长）
2. 若ALU操作时间延长20%，为180ps,依旧小于200ps，对流水线无影响。
3. 若ALU操作时间延长40%，为,小于300ps，对流水线无影响。

## 13
![13](/home/rongzi/Pictures/screenshot/24-06-11_23:24:53.png)
1. 插入一个流水段寄存器
在C、D 之间插入一个流水段寄存器
时钟周期：170ps
时延：190ps
时间：380ps

2. 插入二个流水段寄存器
在B、C 之间插入一个流水段寄存器
在D、E 之间插入一个流水段寄存器
时钟周期：110ps
时延：150ps
时间：450ps


3. 插入三个流水段寄存器
在A、B 之间插入一个流水段寄存器
在C、D 之间插入一个流水段寄存器
在D、E 之间插入一个流水段寄存器
时钟周期：90ps
时延：150ps
时间：600ps

