#  Problem Set 10: 数学归纳法与递归结构
提交截止时间：4 月 8 日 10:00
#  Problem 1
问题: 给出下述集合的递归定义:
a. 正奇数集合.
```
K = 正奇数集合

1 ∈ k
n ∈ k, (n + 2) ∈ k
```

b. 整系数多项式的集合.
```
Z是Z(x) 的子集，其中任何整数 a 可以看作一个常数多项式 a∈Z(x)。

如果 f(x) 和 g(x) 是 Z[x] 中的多项式，则它们的和 f(x)+g(x) 也是 Z[x] 中的多项式。
如果 f(x) 和 g(x) 是 Z[x] 中的多项式，则它们的乘积 f(x)⋅g(x) 也是 Z[x] 中的多项式。
如果 f(x) 是 Z[x] 中的多项式，则其相反数−f(x) 也是 Z[x] 中的多项式。

```

c. 3 的正整数次幂的集合.
```
K = 正奇数集合
1 ∈ K
n ∈ k, (n * 3) ∈ K
```

#  Problem 2
$$当 n 为非负整数时, 证明: n ^ {3} + (n + 1) ^ {3} + (n + 2) ^ {3} 可被 9 整除$$
当n = 0时，原式成立
$$假设当n = k 时，原式成立 n ^ {3} + (n + 1) ^ {3} + (n + 2) ^ {3} = m * 9 , m ∈ Z$$
$$当n = k + 1时，原式等于 n ^ {3} + (n + 1) ^ {3} + (n + 2) ^ {3} + 9n ^ {2} + 27n + 27$$
所以当n = k + 1时依然成立
因此原式成立。

#  Problem 3
$$用数学归纳法证明平面上过同一点的 n 条直线将平面分为 2 ^ {n} 个区域.$$
当n = 0, 原式成立
假设当n = k 原式成立
当n = k + 1时，增加的一条直线可以使得平面上的区域增加2个
$$此时平面中区域为2 ^ {n} + 2个 = 2 ^ {n + 1}$$
故原式成立

#  Problem 4
正整数 n 的拆分是把 n 写成正整数之和的方式. 例如，7 = 3 + 2 + 1 + 1 是 7 的拆分. 设 Pm 等于 m 的不同分拆的数
目, 其中和式里项的顺序无关紧要, 并设 Pm,n 是用不超过 n 的正整数之和来表示 m 的不同方式数.
a. 证明: Pm,n = Pm .
1b. 证明: 下面的 Pm,n 的递归定义是正确的.
c. 用这个递归定义求出 5 和 6 的拆分数.

#  Problem 5
$$证明：当 n 是正整数时，有 f_{1}^{2} + f_{2}^{2} + . . . + f_{n}^{2} = f_{n} * f_{n+1} ，其中 fn 是第 n 个斐波那契数。$$
当n = 1时，原式成立
假设当n = k时，原式成立
当n = k + 1时，
$$左式 = f_{1}^{2} + f_{2}^{2} + . . . + f_{n}^{2} + f_{n + 1}^{2}$$
$$= f_{n} * f_{n+1} + f_{n + 1} ^ {2}$$
$$= f_{n+1} * f_{n+2} ^ {2}$$
所以原式成立

#  Problem 6
证明算术基本定理. 即: 每个大于 1 的自然数, 要么本身就是质数, 要么可以写为 2 个或以上的质数的积. 并且这些质
因子按大小排列之后, 写法仅有一种方式.
当n = 2, 3, 4时候，原式成立
假设当n = k时，原式成立
当n = k + 1
1. n 为质数，原式成立
2. n 不为质数，根据质数定义，
$$n = 2 ^ {x} * 2 ^ {y} * 2 ^ {z} * ... *$$
所以原式成立

#  Problem 7
设 S 是一个正整数集合，定义如下：
基础步骤：1 ∈ S。
$$归纳步骤：如果 n ∈ S，则 3n + 2 ∈ S 且 n ^ {2} ∈ S。$$
a. 证明如果 n ∈ S，则 n ≡ 1(mod 4)。
当n = 1时，原式成立
假设n = 3k + 2时，原式成立
当 n = k + 1时， 左式 = 3k + 5
b. 证明存在一个正整数 m，m ≡ 1(mod 4) 不属于 S。

#  Problem 8
证明：在任意长度有限的 0/1 序列中，字符串 01 至多比字符串 10 多出现 1 次。
假设01比10出现多两次
则该序列中所有0的左侧要么是0要么是空，且这种情况下的01中的0左侧必须为0
所有0的右侧要么是0要么是1
现在选中其中一个01中的0，他的右侧是1，左侧是0
现在选中另一个01中的0，他的右侧是1，左侧是0
任意排列组合都无法满足题意
故假设不成立，命题成立

#  Problem 9
给出当 n 和 m 都是正整数时，求 n! mod m 的递归算法
```
当 n = 1, n! mod m = 1
否则 n! mod m = (n mod m * ((n - 1)! mod m)) mod m
```

# Problem 10
证明：对于任意正整数 n，我们一定能找到数 1, 2, . . . , n 的一个排列，使得在排列中这些数任何两个数的均值都不会
出现在这两个数之间。
当n为偶数
